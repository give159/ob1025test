# 🎓 Python初心者向け完全ガイド - 社員管理システム

## 📚 目次
1. [Pythonの基礎文法](#1-pythonの基礎文法)
2. [クラスとは？](#2-クラスとは)
3. [継承とは？](#3-継承とは)
4. [プロパティとは？](#4-プロパティとは)
5. [デコレータとは？](#5-デコレータとは)
6. [デストラクタとは？](#6-デストラクタとは)
7. [ステップバイステップ実装](#7-ステップバイステップ実装)

---

## 1. Pythonの基礎文法

### 変数の宣言
```python
# 変数名 = 値
name = "太郎"
age = 25
salary = 300000
```

### 型ヒント（Python 3.5以降）
```python
# 変数名: 型 = 値
name: str = "太郎"
age: int = 25
salary: int = 300000
```

### 関数の定義
```python
def greet(name: str) -> str:
    """挨拶する関数"""
    return f"こんにちは、{name}さん"

# 使い方
message = greet("太郎")
print(message)  # こんにちは、太郎さん
```

---

## 2. クラスとは？

### 🤔 クラスって何？
**クラス = 設計図**です！

例えば、「社員」という概念を考えてみましょう：
- すべての社員は「名前」を持っている
- すべての社員は「給料」を持っている

この「設計図」がクラスです。

### 基本的なクラスの書き方

```python
class Employee:
    """社員クラス（設計図）"""
    
    def __init__(self):
        """コンストラクタ：インスタンスが作られる時に実行される"""
        self._name = ""      # 名前（初期値は空文字）
        self._salary = 0     # 給料（初期値は0）
    
    def get_name(self) -> str:
        """名前を取得するメソッド"""
        return self._name
    
    def set_name(self, emp_name: str) -> None:
        """名前を設定するメソッド"""
        self._name = emp_name
```

### 📝 用語解説

| 用語 | 意味 | 例 |
|------|------|-----|
| **クラス** | 設計図 | `class Employee:` |
| **インスタンス** | 設計図から作った実物 | `emp = Employee()` |
| **メソッド** | クラスの中の関数 | `def get_name(self):` |
| **self** | 自分自身を指す | `self._name` |
| **`__init__`** | コンストラクタ（初期化） | オブジェクト作成時に実行 |
| **`_name`** | プライベート変数（外から直接触らない） | アンダースコアで始まる |

### 実際に使ってみよう

```python
# インスタンスを作成（設計図から実物を作る）
emp1 = Employee()

# 名前を設定
emp1.set_name("佐藤太郎")

# 名前を取得
print(emp1.get_name())  # 佐藤太郎
```

---

## 3. 継承とは？

### 🤔 継承って何？
**継承 = 親の特徴を引き継ぐ**です！

例：
- 親：Employee（社員）→ 名前、給料を持つ
- 子：Staff（一般社員）→ 名前、給料 **＋ 所属部署**を持つ

### 継承の書き方

```python
# 親クラス
class Employee:
    def __init__(self):
        self._name = ""
        self._salary = 0
    
    def get_name(self) -> str:
        return self._name

# 子クラス（Employeeを継承）
class Staff(Employee):  # ← (Employee)が継承の印
    def __init__(self):
        super().__init__()  # ← 親のコンストラクタを呼ぶ
        self._division = ""  # ← 新しく追加
    
    def get_division(self) -> str:
        return self._division
```

### 📊 継承の図解

```
    Employee（親）
    ├─ name
    ├─ salary
    └─ get_name()
         ↓ 継承
    Staff（子）
    ├─ name（親から）
    ├─ salary（親から）
    ├─ get_name()（親から）
    └─ division（自分で追加）
```

### super()とは？

`super()` = **親を呼び出す魔法の言葉**

```python
class Staff(Employee):
    def __init__(self):
        super().__init__()  # 親のコンストラクタを実行
        # ↑ これで_nameと_salaryが初期化される
        self._division = ""
```

---

## 4. プロパティとは？

### 🤔 プロパティって何？
**プロパティ = メソッドを変数のように使える機能**

### プロパティなし（通常）
```python
company = Company()
staffs = company.get_staffs()  # メソッド呼び出し
```

### プロパティあり
```python
company = Company()
staffs = company.staffs  # 変数のようにアクセス
```

### プロパティの書き方

```python
class Company:
    def __init__(self):
        self._staffs = []
    
    @property  # ← このデコレータがポイント！
    def staffs(self):
        """staffsプロパティ"""
        return self._staffs
```

### 📝 メリット
- コードが読みやすい
- Pythonらしい書き方
- 内部実装を変えても外部コードに影響しない

---

## 5. デコレータとは？

### 🤔 デコレータって何？
**デコレータ = 関数に機能を追加する魔法**

例：関数の実行前後にログを出力する

### デコレータなし
```python
def greet(name):
    print("関数開始")
    result = f"こんにちは、{name}さん"
    print("関数終了")
    return result
```

### デコレータあり
```python
def log_decorator(func):
    """ログを出力するデコレータ"""
    def wrapper(*args, **kwargs):
        print("関数開始")
        result = func(*args, **kwargs)
        print("関数終了")
        return result
    return wrapper

@log_decorator  # ← デコレータを適用
def greet(name):
    return f"こんにちは、{name}さん"
```

### 📊 今回のデコレータ

```python
def print_employee_count(func):
    """社員数を表示するデコレータ"""
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)  # 元の関数を実行
        total = len(self._staffs) + 1  # 社員数を計算
        print(f"現在わが社の社員数は{total}人になっています")
        return result
    return wrapper

class Company:
    @print_employee_count  # ← デコレータ適用
    def set_dismissal_procedure(self, name: str):
        # 解雇処理
        pass
```

---

## 6. デストラクタとは？

### 🤔 デストラクタって何？
**デストラクタ = オブジェクトが消える時に実行される特殊メソッド**

| メソッド | 呼ばれるタイミング |
|----------|-------------------|
| `__init__` | オブジェクト作成時 |
| `__del__` | オブジェクト削除時 |

### デストラクタの書き方

```python
class Employee:
    def __init__(self):
        self._name = ""
        print(f"[コンストラクタ] {self._name}が作られました")
    
    def __del__(self):
        print(f"[デストラクタ] {self._name}が削除されました")

# 使用例
emp = Employee()
emp._name = "太郎"
# プログラム終了時に自動的に__del__が呼ばれる
```

---

## 7. ステップバイステップ実装

### 🎯 全体の流れ

```
ステップ1: employee.py を作る（親クラス）
  ↓
ステップ2: staff.py を作る（子クラス）
  ↓
ステップ3: president.py を作る（子クラス）
  ↓
ステップ4: company.py を作る（管理クラス）
  ↓
ステップ5: main.py を作る（実行ファイル）
  ↓
ステップ6: テストファイルを作る
```

---

### 📝 ステップ1: employee.py（親クラス）

```python
"""
employee.py
社員基底クラス
"""

class Employee:
    """
    社員の基底クラス
    
    【何を持っている？】
    - 名前（_name）
    - 給料（_salary）
    
    【何ができる？】
    - 名前の取得・設定
    - 給料の取得・設定
    """
    
    def __init__(self):
        """
        コンストラクタ
        オブジェクトが作られる時に実行される
        """
        self._name: str = ""     # 名前を空文字で初期化
        self._salary: int = 0    # 給料を0で初期化
    
    def get_name(self) -> str:
        """
        名前を取得する
        
        Returns:
            str: 社員の名前
        """
        return self._name
    
    def set_name(self, emp_name: str) -> None:
        """
        名前を設定する
        
        Args:
            emp_name (str): 設定する名前
        """
        self._name = emp_name
    
    def get_salary(self) -> int:
        """
        給料を取得する
        
        Returns:
            int: 社員の給料
        """
        return self._salary
    
    def set_salary(self, emp_salary: int) -> None:
        """
        給料を設定する
        
        Args:
            emp_salary (int): 設定する給料
        """
        self._salary = emp_salary
    
    def __del__(self):
        """
        デストラクタ
        オブジェクトが削除される時に実行される
        """
        print(f"[デストラクタ] Employee '{self._name}' が削除されました")
```

**💡 ポイント解説：**
- `self._name` の `_` は「外から直接触らないで」という意味
- `-> str` は「この関数はstr型を返します」という意味
- `-> None` は「この関数は何も返しません」という意味

---

### 📝 ステップ2: staff.py（一般社員クラス）

```python
"""
staff.py
一般社員クラス
"""

from employee import Employee  # ← 親クラスをインポート


class Staff(Employee):  # ← Employee を継承
    """
    一般社員クラス
    
    【継承元】
    - Employee（名前、給料を持っている）
    
    【追加要素】
    - 所属部署（_division）
    
    【できること】
    - 親の機能すべて
    - 部署の取得・設定
    """
    
    def __init__(self):
        """
        コンストラクタ
        """
        super().__init__()        # ← 親のコンストラクタを呼ぶ（重要！）
        self._division: str = ""  # ← 新しく追加した変数
    
    def get_division(self) -> str:
        """
        所属部署を取得する
        
        Returns:
            str: 所属部署名
        """
        return self._division
    
    def set_division(self, emp_division: str) -> None:
        """
        所属部署を設定する
        
        Args:
            emp_division (str): 設定する部署名
        """
        self._division = emp_division
    
    def __del__(self):
        """デストラクタ"""
        print(f"[デストラクタ] Staff '{self._name}' が削除されました")
```

**💡 ポイント解説：**
- `class Staff(Employee)` で Employee を継承
- `super().__init__()` で親のコンストラクタを実行（必須！）
- `self._division` は Staff 独自の変数

---

### 📝 ステップ3: president.py（社長クラス）

```python
"""
president.py
社長クラス
"""

from employee import Employee
from typing import TYPE_CHECKING

# 循環インポート回避のための特殊な書き方
if TYPE_CHECKING:
    from company import Company


class President(Employee):
    """
    社長クラス
    
    【特徴】
    - get_name() をオーバーライド
    - 会社への参照を持つ
    - 社員を解雇できる
    """
    
    def __init__(self, company: 'Company'):
        """
        コンストラクタ
        
        Args:
            company (Company): 所属する会社
        """
        super().__init__()
        self._company: 'Company' = company  # ← 会社への参照
    
    def get_name(self) -> str:
        """
        名前を取得する（オーバーライド）
        
        親のget_name()を上書きして、
        「社長」という肩書きを付ける
        
        Returns:
            str: 名前 + "社長"
        """
        return self._name + "社長"
    
    def dismiss(self, name: str) -> None:
        """
        社員を解雇する
        
        Args:
            name (str): 解雇する社員の名前
        """
        # リスト内包表記：指定された名前以外を残す
        self._company._staffs = [
            staff for staff in self._company._staffs 
            if staff.get_name() != name
        ]
        print(f"[解雇通知] {name}さんを解雇しました")
    
    def __del__(self):
        """デストラクタ"""
        print(f"[デストラクタ] President '{self._name}' が削除されました")
```

**💡 ポイント解説：**
- `get_name()` をオーバーライド（上書き）している
- `self._company` で会社への参照を保持
- リスト内包表記で解雇処理を実装

**🔍 リスト内包表記とは？**
```python
# 通常の書き方
new_list = []
for staff in staffs:
    if staff.get_name() != "太郎":
        new_list.append(staff)

# リスト内包表記（短く書ける）
new_list = [staff for staff in staffs if staff.get_name() != "太郎"]
```

---

### 📝 ステップ4: company.py（会社クラス）

```python
"""
company.py
会社クラス
"""

from typing import List
from functools import wraps
from staff import Staff
from president import President


def print_employee_count(func):
    """
    社員数を表示するデコレータ
    
    【このデコレータの役割】
    関数の実行後に、現在の社員数を表示する
    
    Args:
        func: デコレートする関数
        
    Returns:
        wrapper: ラップされた関数
    """
    @wraps(func)  # ← 元の関数の情報を保持
    def wrapper(self, *args, **kwargs):
        # 元の関数を実行
        result = func(self, *args, **kwargs)
        
        # 社員数を計算（スタッフ + 社長）
        total_employees = len(self._staffs) + 1
        
        # メッセージを表示
        print(f"現在わが社の社員数は{total_employees}人になっています")
        
        return result
    return wrapper


class Company:
    """
    会社クラス
    
    【管理するもの】
    - 社員リスト（_staffs）
    - 社長（_ceo）
    """
    
    def __init__(self):
        """コンストラクタ"""
        self._staffs: List[Staff] = []       # ← 社員リスト
        self._ceo: President = President(self)  # ← 社長
    
    @property  # ← プロパティデコレータ
    def staffs(self) -> List[Staff]:
        """
        社員リストを取得する（プロパティ）
        
        【使い方】
        company.staffs  # ← メソッド呼び出しではない
        
        Returns:
            List[Staff]: 社員のリスト
        """
        return self._staffs
    
    @property
    def ceo(self) -> President:
        """
        社長を取得する（プロパティ）
        
        Returns:
            President: 社長のインスタンス
        """
        return self._ceo
    
    @print_employee_count  # ← デコレータ適用
    def set_dismissal_procedure(self, name: str) -> None:
        """
        解雇手続きを実行する
        
        【処理内容】
        1. 指定された名前の社員を削除
        2. デコレータが社員数を表示
        
        Args:
            name (str): 解雇する社員の名前
        """
        self._staffs = [
            staff for staff in self._staffs 
            if staff.get_name() != name
        ]
        print(f"[解雇手続き完了] {name}さんの解雇手続きが完了しました")
    
    def __del__(self):
        """デストラクタ"""
        print("[デストラクタ] Company が削除されました")
```

**💡 ポイント解説：**
- `@property` で staffs と ceo をプロパティ化
- `@print_employee_count` デコレータで社員数を自動表示
- `List[Staff]` は「Staff のリスト」という型ヒント

---

### 📝 ステップ5: main.py（実行ファイル）

```python
"""
main.py
メインプログラム
"""

from company import Company
from staff import Staff


def main():
    """
    メイン関数
    
    【処理の流れ】
    1. 会社を作成
    2. 社員を追加
    3. 社長を設定
    4. 情報を表示
    """
    print("=" * 60)
    print("社員管理システム")
    print("=" * 60)
    print()
    
    # 1. 会社インスタンスの作成
    company = Company()
    
    # 2. 社員1を作成
    staff1 = Staff()
    staff1.set_name("佐藤太郎")
    staff1.set_salary(200000)
    staff1.set_division("営業部")
    company.staffs.append(staff1)  # ← リストに追加
    
    # 3. 社員2を作成
    staff2 = Staff()
    staff2.set_name("鈴木次郎")
    staff2.set_salary(300000)
    staff2.set_division("開発部")
    company.staffs.append(staff2)
    
    # 4. 社長を設定
    company.ceo.set_name("偉井杉人")
    company.ceo.set_salary(2500000)
    
    # 5. 社員情報を表示
    print("【社員一覧】")
    for staff in company.staffs:
        print(f"名前：{staff.get_name()}、"
              f"給料：{staff.get_salary()}円、"
              f"所属：{staff.get_division()}")
    
    print()
    print("【社長情報】")
    print(f"名前：{company.ceo.get_name()}、"
          f"給料：{company.ceo.get_salary()}円")
    
    print()
    print("=" * 60)


if __name__ == "__main__":
    main()
```

**💡 ポイント解説：**
- `if __name__ == "__main__":` は「直接実行された時だけ」という意味
- `company.staffs.append()` でリストに社員を追加
- f-string（`f"...{変数}..."`）で見やすく表示

---

## 🎯 実行方法

### ステップ1: ファイルを作成

```powershell
notepad employee.py
notepad staff.py
notepad president.py
notepad company.py
notepad main.py
```

### ステップ2: 確認

```powershell
dir *.py
```

### ステップ3: 実行

```powershell
python main.py
```

---

## 📚 まとめ

### 重要な概念

| 概念 | 簡単な説明 | 覚え方 |
|------|----------|--------|
| **クラス** | 設計図 | 「社員ってこういうもの」を定義 |
| **インスタンス** | 実物 | 設計図から作った実際の社員 |
| **継承** | 親の特徴を引き継ぐ | Staff は Employee の子供 |
| **プロパティ** | メソッドを変数風に | `company.staffs` で取得 |
| **デコレータ** | 機能を追加 | `@` マークで適用 |
| **デストラクタ** | 消える時に実行 | `__del__` |

### コーディングのコツ

1. **1つずつ確実に**
   - まず Employee を作る
   - 次に Staff を作る
   - 動作確認しながら進める

2. **エラーを恐れない**
   - エラーメッセージをよく読む
   - Google で検索する
   - 1つずつ解決する

3. **コメントを書く**
   - 「何をするか」を日本語で書く
   - 後で自分が読んでもわかるように

---

## 🎓 次のステップ

このガイドを理解したら：
1. 実際にコードを書いてみる
2. テストコードを書いてみる
3. 新しい機能を追加してみる

頑張ってください！💪✨

"""
===============================================
ステップバイステップ実装ガイド
===============================================

このファイルには各ステップのコードが順番に書かれています。
各ステップごとにコピーして、別ファイルに貼り付けて実行してください。

【学習の流れ】
ステップ1: 基礎を学ぶ → 変数、関数、クラス
ステップ2: employee.py を作る
ステップ3: staff.py を作る（継承を学ぶ）
ステップ4: president.py を作る（オーバーライドを学ぶ）
ステップ5: company.py を作る（プロパティ、デコレータを学ぶ）
ステップ6: main.py を作る（実行する）
ステップ7: テストを作る
"""


# ===============================================
# ステップ1: Python基礎の復習
# ===============================================
"""
【このステップで学ぶこと】
- 変数と型
- 関数の定義
- クラスの基礎
"""

# --- 変数と型 ---
print("=== ステップ1: 基礎の復習 ===\n")

# 基本的な変数
name = "太郎"
age = 25
salary = 300000

print(f"名前: {name}")
print(f"年齢: {age}")
print(f"給料: {salary}")


# --- 関数の定義 ---
def greet(name: str) -> str:
    """挨拶を返す関数"""
    return f"こんにちは、{name}さん！"


message = greet("太郎")
print(f"\n{message}")


# --- 簡単なクラス ---
class Person:
    """人間クラス（練習用）"""
    
    def __init__(self, name: str):
        """コンストラクタ"""
        self.name = name
    
    def introduce(self):
        """自己紹介"""
        return f"私は{self.name}です"


# クラスを使ってみる
person = Person("太郎")
print(f"\n{person.introduce()}")

print("\n" + "=" * 50 + "\n")


# ===============================================
# ステップ2: employee.py（基底クラス）
# ===============================================
"""
【このステップで学ぶこと】
- クラスの定義
- コンストラクタ（__init__）
- メソッドの定義
- デストラクタ（__del__）
- Docstring（ドキュメント）
"""

print("=== ステップ2: Employeeクラスを作る ===\n")


class Employee:
    """
    社員の基底クラス
    
    Attributes:
        _name (str): 社員の名前
        _salary (int): 社員の給料
    """
    
    def __init__(self):
        """
        コンストラクタ
        インスタンス作成時に自動実行される
        """
        self._name: str = ""
        self._salary: int = 0
        print(f"[作成] Employeeインスタンスを作成しました")
    
    def get_name(self) -> str:
        """名前を取得"""
        return self._name
    
    def set_name(self, emp_name: str) -> None:
        """名前を設定"""
        self._name = emp_name
    
    def get_salary(self) -> int:
        """給料を取得"""
        return self._salary
    
    def set_salary(self, emp_salary: int) -> None:
        """給料を設定"""
        self._salary = emp_salary
    
    def __del__(self):
        """
        デストラクタ
        インスタンス削除時に自動実行される
        """
        print(f"[削除] Employee '{self._name}' を削除しました")


# 実際に使ってみる
print("【Employeeクラスのテスト】")
emp = Employee()
emp.set_name("山田太郎")
emp.set_salary(300000)

print(f"名前: {emp.get_name()}")
print(f"給料: {emp.get_salary()}円")

print("\n" + "=" * 50 + "\n")


# ===============================================
# ステップ3: staff.py（継承）
# ===============================================
"""
【このステップで学ぶこと】
- 継承の方法
- super()の使い方
- 親クラスの機能を使う
"""

print("=== ステップ3: Staffクラスを作る（継承） ===\n")


class Staff(Employee):  # ← Employee を継承
    """
    一般社員クラス
    
    Employeeを継承し、部署情報を追加
    
    Attributes:

# 🚨 よくある間違いと解決方法

新人エンジニアが必ずぶつかる壁と、その解決方法をまとめました！

---

## ❌ エラー1: ModuleNotFoundError

### エラーメッセージ
```
ModuleNotFoundError: No module named 'employee'
```

### 原因
- `employee.py` ファイルが存在しない
- 別のフォルダにある
- ファイル名が違う

### 解決方法
```powershell
# 1. 現在のフォルダを確認
cd
# C:\Users\yukik\desktop\excel が表示されるべき

# 2. ファイルがあるか確認
dir *.py

# 3. employee.py がなければ作成
notepad employee.py
```

---

## ❌ エラー2: super().__init__()を忘れた

### 間違ったコード
```python
class Staff(Employee):
    def __init__(self):
        # super().__init__() を忘れた！
        self._division = ""
```

### 症状
- `_name` や `_salary` が初期化されない
- AttributeError が出る

### 正しいコード
```python
class Staff(Employee):
    def __init__(self):
        super().__init__()  # ← これが必須！
        self._division = ""
```

### 覚え方
**「継承したら必ず super().__init__()」**

---

## ❌ エラー3: self を忘れた

### 間違ったコード
```python
class Employee:
    def get_name() -> str:  # selfが無い！
        return _name  # これも間違い
```

### 正しいコード
```python
class Employee:
    def get_name(self) -> str:  # selfを追加
        return self._name  # self.を付ける
```

### ルール
- **メソッドの第一引数は必ず `self`**
- **インスタンス変数には必ず `self.` を付ける**

---

## ❌ エラー4: インデントが違う

### 間違ったコード
```python
class Employee:
    def __init__(self):
        self._name = ""
    self._salary = 0  # インデントが間違い！
```

### 正しいコード
```python
class Employee:
    def __init__(self):
        self._name = ""
        self._salary = 0  # 同じレベルにインデント
```

### Pythonのインデントルール
- **スペース4つ** が標準
- **タブとスペースを混ぜない**
- VSCode や PyCharm を使うと自動整形してくれる

---

## ❌ エラー5: 循環インポート

### 間違ったコード

**company.py**
```python
from president import President

class Company:
    pass
```

**president.py**
```python
from company import Company  # ← 循環参照！

class President:
    pass
```

### 正しいコード

**president.py**
```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from company import Company  # 型チェック時のみ

class President:
    def __init__(self, company: 'Company'):  # 文字列で指定
        self._company = company
```

---

## ❌ エラー6: プロパティの使い方間違い

### 間違ったコード
```python
company = Company()
print(company.staffs())  # ← ()を付けてはダメ！
```

### 正しいコード
```python
company = Company()
print(company.staffs)  # ← ()なしで取得
```

### プロパティとメソッドの違い

| 種類 | 定義 | 使い方 |
|------|------|--------|
| メソッド | `def get_staffs(self):` | `obj.get_staffs()` |
| プロパティ | `@property def staffs(self):` | `obj.staffs` |

---

## ❌ エラー7: リスト内包表記の間違い

### 間違ったコード
```python
# セミコロンではなくカンマ！
new_list = [staff; for staff in staffs]
```

### 正しいコード
```python
new_list = [staff for staff in staffs]
```

### リスト内包表記の構文
```python
[式 for 変数 in イテラブル if 条件]
```

### 例
```python
# すべての社員
all_staff = [s for s in staffs]

# 給料が30万以上の社員
high_salary = [s for s in staffs if s.get_salary() >= 300000]

# 名前だけ取得
names = [s.get_name() for s in staffs]
```

---

## ❌ エラー8: デコレータの位置間違い

### 間違ったコード
```python
class Company:
    def set_dismissal_procedure(self, name):
        pass
    
    @print_employee_count  # ← メソッドの後はダメ！
```

### 正しいコード
```python
class Company:
    @print_employee_count  # ← メソッドの前
    def set_dismissal_procedure(self, name):
        pass
```

---

## ❌ エラー9: 型ヒントの間違い

### 間違ったコード
```python
def get_name(self) -> string:  # string ではなく str
    return self._name
```

### 正しいコード
```python
def get_name(self) -> str:  # str が正しい
    return self._name
```

### Pythonの基本型

| 型 | 型ヒント | 例 |
|----|----------|-----|
| 文字列 | `str` | `"太郎"` |
| 整数 | `int` | `25` |
| 浮動小数点 | `float` | `3.14` |
| 真偽値 | `bool` | `True` |
| リスト | `List[型]` | `[1, 2, 3]` |
| 辞書 | `Dict[キー型, 値型]` | `{"a": 1}` |
| なし | `None` | `None` |

---

## ❌ エラー10: Docstringの形式間違い

### 間違ったコード
```python
def get_name(self):
    # これはコメント（Docstringではない）
    return self._name
```

### 正しいコード
```python
def get_name(self) -> str:
    """
    名前を取得する
    
    Returns:
        str: 社員の名前
    """
    return self._name
```

### Docstringのルール
- **三重クォート `"""` で囲む**
- **関数の直後に書く**
- **何をするかを説明**

---

## 🎯 デバッグのコツ

### 1. print()デバッグ
```python
def dismiss(self, name: str):
    print(f"[DEBUG] 解雇対象: {name}")
    print(f"[DEBUG] 現在の社員数: {len(self._company._staffs)}")
    
    self._company._staffs = [
        staff for staff in self._company._staffs 
        if staff.get_name() != name
    ]
    
    print(f"[DEBUG] 解雇後の社員数: {len(self._company._staffs)}")
```

### 2. type()で型確認
```python
staffs = company.staffs
print(type(staffs))  # <class 'list'>
```

### 3. dir()で使えるメソッド確認
```python
emp = Employee()
print(dir(emp))  # 使えるメソッド一覧が出る
```

---

## 📚 エラーメッセージの読み方

### エラーメッセージの構造
```
Traceback (most recent call last):
  File "main.py", line 10, in <module>
    company.staffs()
TypeError: 'list' object is not callable
```

### 読み方
1. **最後の行** を最初に見る
   - `TypeError: 'list' object is not callable`
   - 「リストは呼び出せない」= `()`を付けてはダメ

2. **File "main.py", line 10** でエラーの場所を確認
   - main.py の 10行目を見る

3. **エラーの種類** を理解する
   - `TypeError`: 型が違う
   - `AttributeError`: 存在しない属性
   - `NameError`: 変数が定義されていない
   - `IndentationError`: インデントが間違い

---

## 🔍 よくある質問

### Q1: `_name` と `name` の違いは？
**A:** 
- `_name`: プライベート変数（外から直接触らない）
- `name`: パブリック変数（どこからでもアクセス可）

Pythonでは **`_` で始まる変数は「触らないで」** という意味です。

### Q2: なぜ `get_name()` と `set_name()` を使うの？
**A:** 
- データの隠蔽（カプセル化）
- 値のチェックができる
- 将来の変更に強い

```python
def set_salary(self, emp_salary: int):
    if emp_salary < 0:
        raise ValueError("給料は0以上である必要があります")
    self._salary = emp_salary
```

### Q3: `__init__` と `__del__` の `__` は何？
**A:** 
- `__` で囲まれたメソッドは **特殊メソッド（マジックメソッド）**
- Python が自動的に呼び出す
- 自分で `obj.__init__()` と呼ぶことは通常しない

### Q4: クラス変数とインスタンス変数の違いは？
**A:**
```python
class Employee:
    # クラス変数（すべてのインスタンスで共有）
    company_name = "ABC株式会社"
    
    def __init__(self):
        # インスタンス変数（各インスタンスごと）
        self._name = ""
```

---

## 💡 成功のための5つのヒント

### 1. 小さく始める
❌ いきなり全部書く
✅ 1つのクラスから始めて、動作確認

### 2. こまめにテスト
❌ 全部書いてからテスト
✅ 1つの機能ごとにテスト

### 3. エラーを恐れない
❌ エラーが出たらパニック
✅ エラーメッセージをよく読んで調べる

### 4. コメントを書く
❌ コードだけ書く
✅ 何をしているか日本語で書く

### 5. 人に聞く
❌ 1人で悩み続ける
✅ ChatGPT や先輩に聞く

---

## 🎓 まとめ

### よくある間違いトップ3
1. **super().__init__() を忘れる**
2. **self を忘れる**
3. **インデントが間違っている**

### エラーが出たら
1. エラーメッセージを読む
2. Google で検索
3. print() でデバッグ
4. 人に聞く

### 上達のコツ
- 毎日少しずつコードを書く
- エラーを恐れない
- 他人のコードを読む
- 実際に動かしてみる

**頑張ってください！ 💪✨**
