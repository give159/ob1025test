# IPO設計書の書き方ガイド
## 良い例・悪い例で学ぶ実践的な設計書作成

---

## 📌 IPOとは？

**IPO = Input（入力）→ Process（処理）→ Output（出力）**

プログラムの機能を「入力・処理・出力」の3段階で明確に定義する設計手法です。

---

## 1. 基本的な書き方

### ❌ 悪い例：曖昧で実装できない

```
機能: ユーザー登録

処理内容:
ユーザー情報を登録する
```

**問題点：**
- 何を入力するのか不明
- どう処理するのか不明
- 何が返ってくるのか不明
- これでは実装できない


### ✅ 良い例：具体的で実装可能

```
機能ID: REG-001
機能名: ユーザー登録

【Input】
- ユーザーID（文字列、必須、8-20文字、半角英数字）
- パスワード（文字列、必須、8文字以上、英数字記号混在）
- メールアドレス（文字列、必須、メール形式）

【Process】
1. 入力値のバリデーション
   - 形式チェック
   - 文字数チェック
   - 必須チェック
2. ユーザーID重複チェック
3. パスワードのハッシュ化（SHA-256）
4. データベースへ保存

【Output】
- 成功時: ユーザーID、登録日時、成功メッセージ
- 失敗時: エラーコード、エラーメッセージ
```

**改善点：**
- ✅ 入力の型・制約が明確
- ✅ 処理の順序が分かる
- ✅ 出力の種類が分かる
- ✅ すぐに実装に移れる

---

## 2. データ型の定義

### ❌ 悪い例：型が不明

```
【Input】
- 商品番号
- 数量
- 金額
```

**問題点：**
- 数値か文字列か不明
- 範囲が不明
- 必須かオプションか不明


### ✅ 良い例：型と制約を明記

```
【Input】
- 商品番号（文字列、必須、形式: "PRD-XXXXX"、X=数字）
- 数量（整数、必須、範囲: 1-999）
- 金額（整数、必須、範囲: 0-9,999,999、単位: 円）
- 備考（文字列、任意、最大500文字）
```

**改善点：**
- ✅ データ型が明確
- ✅ 必須/任意が明確
- ✅ 制約条件が明確
- ✅ 実装時の判断が不要

---

## 3. 処理の書き方

### ❌ 悪い例：処理が抽象的

```
【Process】
データをチェックして保存する
```

**問題点：**
- 何をチェックするのか不明
- チェックの順序が不明
- エラー時の挙動が不明


### ✅ 良い例：ステップごとに明記

```
【Process】
Step 1: 入力値バリデーション
  1-1. 商品番号の形式チェック
  1-2. 数量の範囲チェック（1-999）
  1-3. 金額の範囲チェック（0-9,999,999）
  → NG: エラーコード E001 を返して終了

Step 2: 在庫確認
  2-1. 商品番号で在庫テーブルを検索
  2-2. 在庫数 ≧ 数量 をチェック
  → NG: エラーコード E002 を返して終了

Step 3: データ保存
  3-1. トランザクション開始
  3-2. 注文テーブルへ挿入
  3-3. 在庫テーブルを更新（在庫数 - 数量）
  3-4. コミット
  → 失敗時: ロールバック、エラーコード E003

Step 4: 完了通知
  4-1. 注文番号を生成（形式: ORD-YYYYMMDD-XXXXX）
  4-2. 成功メッセージを作成
```

**改善点：**
- ✅ 処理の順序が明確
- ✅ 判定条件が明確
- ✅ エラー処理が明確
- ✅ 実装漏れが防げる

---

## 4. 出力の書き方

### ❌ 悪い例：出力が曖昧

```
【Output】
結果を返す
```

**問題点：**
- 成功時と失敗時の違いが不明
- 返却値の形式が不明
- 何を使って判定するのか不明


### ✅ 良い例：パターン別に明記

```
【Output】

パターン1: 成功時
  戻り値の型: JSON
  戻り値の内容:
    {
      "status": "success",
      "order_id": "ORD-20251025-00001",
      "total_amount": 15000,
      "message": "注文が完了しました"
    }
  HTTPステータス: 200

パターン2: バリデーションエラー（E001）
  戻り値の型: JSON
  戻り値の内容:
    {
      "status": "error",
      "error_code": "E001",
      "message": "入力値が不正です",
      "details": "数量は1-999の範囲で指定してください"
    }
  HTTPステータス: 400

パターン3: 在庫不足エラー（E002）
  戻り値の型: JSON
  戻り値の内容:
    {
      "status": "error",
      "error_code": "E002",
      "message": "在庫が不足しています",
      "available_stock": 5
    }
  HTTPステータス: 409

パターン4: システムエラー（E003）
  戻り値の型: JSON
  戻り値の内容:
    {
      "status": "error",
      "error_code": "E003",
      "message": "システムエラーが発生しました"
    }
  HTTPステータス: 500
```

**改善点：**
- ✅ 全パターンを網羅
- ✅ 具体的な値の例
- ✅ HTTPステータスも明記
- ✅ テストケースが作りやすい

---

## 5. 実例の書き方

### ❌ 悪い例：例がない

```
【Input】
- ユーザーID
- パスワード

【Output】
- 認証結果
```

**問題点：**
- 具体的なイメージが湧かない
- 実装者によって解釈が異なる


### ✅ 良い例：具体例を記載

```
【Input】
- ユーザーID（文字列）
- パスワード（文字列）

【Process】
1. ユーザーIDでDB検索
2. パスワードをハッシュ化して照合
3. 一致すればセッションIDを発行

【Output】
- 成功時: セッションID、ユーザー情報
- 失敗時: エラーメッセージ

【実行例1: 成功パターン】
Input:
  user_id: "user001"
  password: "Pass1234!"

Process:
  1. user001 を検索 → 存在
  2. ハッシュ照合 → 一致
  3. セッションID生成 → "sess_abc123xyz"

Output:
  {
    "session_id": "sess_abc123xyz",
    "user_name": "ユーザーA",
    "login_time": "2025-10-25T10:30:00Z"
  }

【実行例2: 失敗パターン】
Input:
  user_id: "user999"
  password: "wrongpass"

Process:
  1. user999 を検索 → 不在

Output:
  {
    "error_code": "AUTH001",
    "message": "ユーザーIDまたはパスワードが間違っています"
  }
```

**改善点：**
- ✅ 具体的な値で示している
- ✅ 成功・失敗の両方がある
- ✅ イメージしやすい
- ✅ テストデータとして使える

---

## 6. エラー処理の書き方

### ❌ 悪い例：エラーが曖昧

```
【Process】
データをチェックする
エラーがあれば処理を止める
```

**問題点：**
- どんなエラーがあるのか不明
- エラーコードがない
- エラーメッセージが不明


### ✅ 良い例：エラーを明確に定義

```
【エラー定義】

エラーコード: E001
  発生条件: 必須項目が未入力
  Input例: user_id = ""
  Process: バリデーション Step 1 で検出
  Output: {
    "error_code": "E001",
    "message": "必須項目が入力されていません",
    "field": "user_id"
  }

エラーコード: E002
  発生条件: データ形式が不正
  Input例: email = "invalid-email"
  Process: バリデーション Step 2 で検出
  Output: {
    "error_code": "E002",
    "message": "メールアドレスの形式が正しくありません",
    "field": "email"
  }

エラーコード: E003
  発生条件: データベース接続エラー
  Input: （正常な値でも発生しうる）
  Process: DB接続時に発生
  Output: {
    "error_code": "E003",
    "message": "システムエラーが発生しました。しばらく経ってから再度お試しください"
  }
  対処: ログ出力、管理者通知
```

**改善点：**
- ✅ エラーコードが体系化
- ✅ 発生条件が明確
- ✅ ユーザー向けメッセージ
- ✅ 運用時の対処法も記載

---

## 7. バリデーションの書き方

### ❌ 悪い例：チェック内容が不明

```
【Input】
- メールアドレス（必須）

【Process】
メールアドレスをチェックする
```

**問題点：**
- 何をチェックするのか不明
- チェック順序が不明
- 複数エラーの扱いが不明


### ✅ 良い例：チェック項目を列挙

```
【Input】
- メールアドレス（文字列、必須）

【Validation Rules】

Rule 1: NULL/空チェック
  条件: 値が NULL または空文字列
  判定: NG
  エラー: "メールアドレスを入力してください"

Rule 2: 文字数チェック
  条件: 6文字未満 または 254文字超
  判定: NG
  エラー: "メールアドレスは6-254文字で入力してください"

Rule 3: 形式チェック
  正規表現: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
  判定: 一致しない場合 NG
  エラー: "メールアドレスの形式が正しくありません"

Rule 4: 重複チェック
  処理: データベースで既存確認
  条件: 同じメールアドレスが存在
  判定: NG
  エラー: "このメールアドレスは既に登録されています"

【チェック順序】
1. Rule 1 → NG なら終了
2. Rule 2 → NG なら終了
3. Rule 3 → NG なら終了
4. Rule 4 → NG なら終了
5. 全て OK なら次の処理へ

【実行例】
Input: "test@example"
  → Rule 3 で NG（ドメイン部にTLDがない）
  → Output: エラーコード V003
```

**改善点：**
- ✅ ルールが明確
- ✅ チェック順序が明確
- ✅ エラーメッセージが具体的
- ✅ テストしやすい

---

## 8. テストケースの書き方

### ❌ 悪い例：テストが抽象的

```
テスト項目:
- 正常に動作することを確認
- エラーが出ることを確認
```

**問題点：**
- 具体的な値がない
- 期待結果が不明
- 再現できない


### ✅ 良い例：IPO形式で明確に

```
【テストケース TC-001】正常系：標準的な登録

Input:
  user_id: "testuser01"
  password: "Pass1234!"
  email: "test@example.com"

Expected Process:
  1. バリデーション → 全て OK
  2. 重複チェック → 重複なし
  3. パスワードハッシュ化 → 完了
  4. DB保存 → 成功

Expected Output:
  status: "success"
  user_id: "testuser01"
  created_at: （実行時刻）
  message: "登録が完了しました"

判定基準:
  - HTTPステータス = 200
  - DBに1レコード追加されている
  - パスワードは平文で保存されていない


【テストケース TC-002】異常系：必須項目未入力

Input:
  user_id: ""
  password: "Pass1234!"
  email: "test@example.com"

Expected Process:
  1. バリデーション → Rule 1 で NG
  2. 処理中断

Expected Output:
  status: "error"
  error_code: "E001"
  message: "ユーザーIDを入力してください"
  field: "user_id"

判定基準:
  - HTTPステータス = 400
  - DBに保存されていない


【テストケース TC-003】異常系：重複登録

Input:
  user_id: "existing_user"  （既に存在）
  password: "Pass1234!"
  email: "new@example.com"

Expected Process:
  1. バリデーション → OK
  2. 重複チェック → 重複あり
  3. 処理中断

Expected Output:
  status: "error"
  error_code: "E004"
  message: "このユーザーIDは既に使用されています"

判定基準:
  - HTTPステータス = 409
  - DBのレコード数が変わっていない
```

**改善点：**
- ✅ 正常系・異常系を網羅
- ✅ 具体的な値で記載
- ✅ 期待結果が明確
- ✅ そのままテストコードに変換できる

---

## 9. パフォーマンス要件

### ❌ 悪い例：要件が曖昧

```
処理は速く行うこと
```

**問題点：**
- 「速い」の定義が不明
- 測定方法が不明
- 合否判定ができない


### ✅ 良い例：数値で明確に

```
【パフォーマンス要件】

機能: ユーザー検索

Input条件:
  - 検索対象データ: 100万件
  - 検索キーワード: 1-50文字

Process:
  - インデックスを使用した検索
  - 結果の並び替え

Output:
  - 最大100件を返却

性能目標:
  - 平均応答時間: 0.3秒以内
  - 95パーセンタイル: 0.5秒以内
  - 最大応答時間: 1.0秒以内
  - 同時接続数: 100ユーザー
  - エラー率: 0.1%以下

測定条件:
  - 測定環境: 本番相当の環境
  - 測定回数: 1000回
  - 負荷パターン: 一定負荷

【実行例】
Input: keyword = "test"
Process時間: 
  DB検索 0.15秒
  結果整形 0.05秒
  合計 0.20秒
Output: 25件のデータ
判定: OK（0.3秒以内）
```

**改善点：**
- ✅ 数値目標が明確
- ✅ 測定方法が明確
- ✅ 合否判定ができる
- ✅ 実測データと比較できる

---

## 10. まとめ：IPO設計書チェックリスト

### ✅ Input（入力）のチェックポイント
- [ ] データ型が明記されている（文字列、整数、など）
- [ ] 必須/任意が明記されている
- [ ] 制約条件が明記されている（文字数、範囲、形式）
- [ ] 具体例が記載されている

### ✅ Process（処理）のチェックポイント
- [ ] 処理がステップごとに分解されている
- [ ] 処理の順序が明確
- [ ] 判定条件が明確（〇〇の場合、××する）
- [ ] エラー時の挙動が明確
- [ ] 外部システム連携がある場合は明記

### ✅ Output（出力）のチェックポイント
- [ ] 成功時の出力が明記されている
- [ ] 失敗時の出力が明記されている（パターン別）
- [ ] データ形式が明記されている（JSON、XML、など）
- [ ] エラーコードとメッセージが定義されている
- [ ] 具体例が記載されている

### ✅ 全体のチェックポイント
- [ ] 実装者が迷わず実装できる
- [ ] テストケースが作成できる
- [ ] レビューで指摘できる具体性がある
- [ ] 個人情報などの機密情報が含まれていない

---

## 補足：避けるべき表現

| ❌ 悪い表現 | ✅ 良い表現 |
|----------|----------|
| "適切に処理する" | "XXXをチェックし、条件Yなら△△する" |
| "データを保存する" | "テーブルZにカラムA,B,Cを保存する" |
| "エラーを返す" | "エラーコードE001とメッセージ「XXX」を返す" |
| "高速に動作する" | "0.3秒以内に応答する" |
| "なるべく〜する" | "必ず〜する" または "〜の場合に限り〜する" |

---

この書き方を実践すれば、**実装者が迷わない**、**テストしやすい**、**メンテナンスしやすい**設計書が作成できます！
